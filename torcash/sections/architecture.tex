\section{Proposed Architecture} \label{arch}

We now discuss the main components necessary to realize a practical Tor
incentive system while identifying some open research and development problems.

\subsection{Overview}
We propose a system that measures bandwidth contributed to the Tor network to produce incentivise the addition of nodes to the Tor network.
The system measures the bandwidth contributed by each relay in the Tor network and rewards them with a 'TorCoin'. A Torcoin is an AltCoin that uses a bandwidth-intensive protocol as its proof-of-work. Thus, to produce a TorCoin, a relay must have transmitted a certain amount of Tor traffic.
To reduce the system's vulnerability to attackers and possible reduction of anonymity, we also utilize a system of 'Ephemeral Paths' to randomly assign relays to clients.
These TorCoins can then be traded at an exchange for other AltCoins or other goods. This forms the basis of our incentivization scheme. This is different from systems that propose differentiated service\cite{dovrolis1999case, dovrolis2002proportional}, since we do not propose to make the clients pay for access to the network. The coins are a byproduct of the usage of the system.

\subsection{Ephemeral Paths}
We propose the novel idea of ephemeral Tor networks, where a \textit{group} of n clients at any given time form a consensus on an assignment of n routes to n clients, such that each route is publicly verifiable but privately addressable. We adhere to the following constraints:
\begin{itemize}
  \item No client in the group can generate its own route.
  \item Every resulting route has a unique public key.
  \item No client in the group can know the route assigned to another client in the group.
  \item Any client can verify that a given public key represents a route assigned to a client in the current group.
\end{itemize}

The Tor directory servers will create the groups using the temporal locality of the clients connecting to them, but also ensure that their is geographical and other diversity in a group. This is to ensure that adversaries cannot deterministically place themselves in a single group by connecting at the same time.
The Tor directory server will then initiate the setup protocol amongst the clients in each group. Each group will then perform a series of Neff Shuffles to produce a random combination of routes for each client in the group. This will be combined with El Gamal encryption to preserve anonymity within the group.

\subsubsection{Decentralized Neff Shuffle for Consensus Tor Route Assignment to n Clients}
We perform a series of Neff shuffles so that each client in the group is assigned one \textit{route} consisting of an entry, middle and exit relay. The route also has a publicly verifiable shared secret. That is, a route can collectively sign a TorCoin (explained later) such that any client in the group can verify that the signature came from a route assigned to another client in the group.

\paragraph{Implementation of Neff Shuffle}

THIS SECTION NEEDS TO BE MADE CLEARER / DIAGRAM

The clients are numbered 1 through N

Entry relays 1 to Me; 

Middle relays: 1 through Mm; 

Exit relays: 1 through Mx.

1.  Each list of relays and clients goes through an independent Neff shuffle. The shuffled lists are concatenated, producing a shuffled 4xN matrix. Each client will have one row assigned to it, which only that client can verifiably associate with. This row represents the route for that client.

2.  Each client can use their own private key to find out their own row and assigned relays after the shuffle, but no one else can.

3.  The directory server generates a public and private key for all members of the row. This functions as the shared secret for the route.

It may be possible to use cryptographic accumulators along with the Neff shuffle. In that case, it will not be necessary to keep all the public keys generated in part 3. Instead, the keys may be used to generate a cryptographic accumulator and this accumulator can be used to provide a zero-knowledge verification of group-membership.

We can then generate a publicly verifiable shared secret amongst the relays in any given route (a row in the 4XN matrix). That is, a route can collectively sign a TorCoin such that any client in the consensus group can verify that the signature came from a route assigned to another client in the consensus group.

\subsubsection{Proof of Bandwidth}
Once the routes are setup, we can prove bandwidth transfer through the following protocol:
Every n Tor packets, the client sends an extra packet (“the Torcoin packet”) containing an hash attempt likely to generate a TorCoin. Relay A gets it, generates a temporary private key Ka (generated using the route shared key) and hashes the received packet and this key. It then forwards it to B, which does the same thing, with its own private temporary key Kb. Similarly on to C. C can now add its own Kc, and if it generates a hash with a given number of zeros, it can claim to have found a TorCoin.
\begin{verbatim}
Client sends to A: T0 (its hash attempt)
A sends to B     : Hash(T0 + K1) = Ta # K1 is A's temporary private key.
B sends to C     : Hash(Ta + K2) = Tb # K2 is B’s temporary private key.
C computes       : Hash(Tb + K3) = Tc # K3 is C’s temporary private key.
C sends to B     : (Tc, K3) to verify.
B sends to A     : (Tc, K3, Tb, K2) to verify.
A sends to client: (Tc, K3, Tb, K2, Ta, K1) to verify.
Once the client has verified the hash, we can confirm that the data has made a 
round trip through the route. This completes the proof of bandwidth.
\end{verbatim}

\subsubsection{TorCoin}
We can also implement an AltCoin based on the proof-of-work concept in the following manner:
\begin{verbatim}
If (Tc = '000...')
  If the client succesfully verifies the hash
    It adds the coin to the blockchain with the following information:
    1. Client’s public key
    2. Route Shared key (Lets any other group member verify that the route is 
       genuine. See accumulator/Neff’s key.)
    3. TorCoin Hash
    It then gives 1/3rd of the coin to each of the relays in the route. (If the 
    client is rogue, can we identify and kick the client off?)
\end{verbatim}

\subsection{Robustness to attack}
The entire reason for constructing the elaborate ephemeral routes algorithm is to make the Torcoin system robust to attackers.
Due to the random group selection system, it is hard for attackers to deterministically place themselves in a group. In addition, because the attacker needs to control all four components fo a route to mint a TorCoin fraudulently, even if the adversaries control up to half the network, there is a probability of only 1/16 that an adversary client gets a path of three colluding relays. In practice, gaining control of half of the entire Tor client and relay network is practically impossible. 
A separate rate-limiting mechanism can be deployed to detect dishonest relays and assign them a lower weightage in the path selection procedure. An independent verification authority, such as one based on Eigenspeed, could be used to detect these discrepancies.