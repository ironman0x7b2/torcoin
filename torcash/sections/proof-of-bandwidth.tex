\section{Proof of Bandwidth}

Because the current Tor measurement scheme has been shown to be easily manipulable~\cite{biryukov2013trawling}, we will need to use a different approach to bandwidth measurement or design a new one. This section discusses how the state-of-the-art in distributed system bandwidth measurement may be applied to Tor, and offers an alternative scheme that may also be used for bandwidth accounting purposes.

\subsection{EigenSpeed}

Discuss here how EigenSpeed~\cite{snader2009eigenspeed} or something similar~\cite{snader2008tune, snader2011improving} may be used in the context of Tor and how our incentive system may take advantage of it.

\subsection{Ephemeral Paths}

We propose the novel idea of ephemeral Tor networks, where a \textit{group} of n clients at any given time form a consensus on an assignment of n routes to n clients, such that each route is publicly verifiable but privately addressable. We adhere to the following constraints:

\begin{itemize}
  \item No client in the group can generate its own route.
  \item Every resulting route has a unique public key.
  \item No client in the group can know the route assigned to another client in the group.
  \item Any client can verify that a given public key represents a route assigned to a client in the current group.
\end{itemize}

We will accomplish this using a Tor directory server to initiate the setup protocol amongst the clients, and then a decentralized Neff Shuffle combined with El Gamal encryption to assign the routes according to the above constraints.

\subsubsection{Decentralized Neff Shuffle for Consensus Tor Route Assignment to n Clients}
We perform a series of Neff shuffles so that each client in the group is assigned one \textit{route} consisting of an entry, middle and exit relay. The route also has a publicly verifiable shared secret. That is, a route can collectively sign a TorCoin (explained later) such that any client in the group can verify that the signature came from a route assigned to another client in the group.

\paragraph{Implementation of Neff Shuffle}
\begin{verbatim}
THIS SECTION NEEDS TO BE MADE CLEARER / DIAGRAM
Number the clients 1 through n; Entry relay 1 to Me; Middle: 1 through Mm; 
Exit: 1 through Mx.
Each has lists of public keys: Gx. If required, repeat some of the elements in 
each column to make a 4XN matrix.
Now, each column goes through a Neff producing a shuffled 4XN matrix. Each 
client will have one row assigned to it, which only that client can verifiably 
associate with. This row will represent the route for that client.
If just shuffling public keys - preserve the private keys and change the base to
 h = gx1x2..xn (This is apparently explained in the latter section called Neff 
 Key shuffle)
Because the client has their own private key they can figure out where they are 
after the shuffle, but no one else can. (Client knows its own private key and h,
so apparently it can figure out which row belongs to it.)
Servers generate a public and private key for all members of the row. This 
functions as the shared secret for the route.
\end{verbatim}

\subsubsection{Proof of Bandwidth}
Once the routes are setup, we can prove bandwidth transfer through the following protocol:
Every n Tor packets, the client sends an extra packet (“the Torcoin packet”) containing an hash attempt likely to generate a TorCoin. Relay A gets it, generates a temporary private key Ka (generated using the route shared key) and hashes the received packet and this key. It then forwards it to B, which does the same thing, with its own private temporary key Kb. Similarly on to C. C can now add its own Kc, and if it generates a hash with a given number of zeros, it can claim to have found a TorCoin.
  \begin{verbatim}
  Client sends to A: T0 (its hash attempt)
  A sends to B     : Hash(T0 + K1) = Ta # K1 is A's temporary private key.
  B sends to C     : Hash(Ta + K2) = Tb # K2 is B’s temporary private key.
  C computes       : Hash(Tb + K3) = Tc # K3 is C’s temporary private key.
  C sends to B     : (Tc, K3) to verify.
  B sends to A     : (Tc, K3, Tb, K2) to verify.
  A sends to client: (Tc, K3, Tb, K2, Ta, K1) to verify.
  Once the client has verified the hash, we can confirm that the data has made a 
  round trip through the route. This completes the proof of bandwidth.
  \end{verbatim}

\subsubsection{TorCoin}
We can also implement an AltCoin based on the proof-of-work concept in the following manner:
  \begin{verbatim}
  If (Tc = '000...')
    If the client succesfully verifies the hash
      It adds the coin to the blockchain with the following information:
      1. Client’s public key
      2. Route Shared key (Lets any other group member verify that the route is 
         genuine. See accumulator/Neff’s key.)
      3. TorCoin Hash
      It then gives 1/3rd of the coin to each of the relays in the route. (If the 
      client is rogue, can we identify and kick the client off?)
  \end{verbatim}